<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DatabaseHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Kukumo::Database Steps</a> &gt; <a href="index.source.html" class="el_package">iti.kukumo.database</a> &gt; <span class="el_source">DatabaseHelper.java</span></div><h1>DatabaseHelper.java</h1><pre class="source lang-java linenums">/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

/**
 * @author Luis IÃ±esta Gelabert - linesta@iti.es | luiinge@gmail.com
 */
package iti.kukumo.database;


import iti.kukumo.api.KukumoException;
import iti.kukumo.api.datatypes.Assertion;
import iti.kukumo.database.dataset.*;
import net.sf.jsqlparser.JSQLParserException;
import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.JdbcParameter;
import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.statement.StatementVisitorAdapter;
import net.sf.jsqlparser.statement.delete.Delete;
import net.sf.jsqlparser.statement.insert.Insert;
import net.sf.jsqlparser.statement.select.PlainSelect;
import net.sf.jsqlparser.statement.select.Select;
import net.sf.jsqlparser.statement.update.Update;
import org.assertj.core.api.Assertions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import slf4jansi.AnsiLogger;

import java.io.IOException;
import java.sql.*;
import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;


public class DatabaseHelper {

    public interface ConnectionProvider {

        Connection obtainConnection() throws SQLException;
    }


<span class="fc" id="L49">    private static final Logger LOGGER = AnsiLogger.of(LoggerFactory.getLogger(&quot;iti.kukumo.database&quot;));</span>

<span class="fc" id="L51">    private final Map&lt;String, String[]&gt; primaryKeyCache = new HashMap&lt;&gt;();</span>
<span class="fc" id="L52">    private final Map&lt;String, Map&lt;String, Integer&gt;&gt; nonNullabeColumnCache = new HashMap&lt;&gt;();</span>
    private final ConnectionProvider connectionProvider;
    private final ConnectionParameters connectionParameters;
<span class="fc" id="L55">    private final Deque&lt;Runnable&gt; cleanUpOperations = new LinkedList&lt;&gt;();</span>
    private final Supplier&lt;String&gt; nullSymbol;
    private SQLParser parser;
    private Runnable manualCleanup;

<span class="fc" id="L60">    private CaseSensitivity caseSensitivity = CaseSensitivity.INSENSITIVE;</span>

    public DatabaseHelper(
        ConnectionParameters connectionParameters,
        ConnectionProvider connectionProvider,
        Supplier&lt;String&gt; nullSymbol
<span class="fc" id="L66">    ) {</span>
<span class="fc" id="L67">        this.connectionProvider = connectionProvider;</span>
<span class="fc" id="L68">        this.connectionParameters = connectionParameters;</span>
<span class="fc" id="L69">        this.nullSymbol = nullSymbol;</span>
<span class="fc" id="L70">        this.parser = new SQLParser(caseSensitivity);</span>
<span class="fc" id="L71">        AnsiLogger.addStyle(&quot;sql&quot;,&quot;yellow,bold&quot;);</span>
<span class="fc" id="L72">    }</span>


    protected Connection connection() throws SQLException {
<span class="fc" id="L76">        return connectionProvider.obtainConnection();</span>
    }

    public DatabaseHelper setCaseSensitivity(CaseSensitivity caseSensitivity) {
<span class="fc" id="L80">        this.caseSensitivity = caseSensitivity;</span>
<span class="fc" id="L81">        this.parser = new SQLParser(caseSensitivity);</span>
<span class="fc" id="L82">        return this;</span>
    }

    public DatabaseHelper setCleanUpOperations(String sql) {
<span class="nc" id="L86">        manualCleanup = () -&gt; {</span>
            try {
<span class="nc" id="L88">                executeSQLStatements(sql, false);</span>
<span class="nc" id="L89">            } catch (SQLException | JSQLParserException e) {</span>
<span class="nc" id="L90">                LOGGER.debug(&quot;Error on clean-up operation: {}&quot;, e.getMessage(), e);</span>
<span class="nc" id="L91">            }</span>
<span class="nc" id="L92">        };</span>
<span class="nc" id="L93">       return this;</span>
    }

    public DatabaseHelper setCleanUpOperations(String sql, String fileName) {
<span class="nc" id="L97">        manualCleanup = () -&gt; {</span>
            try {
<span class="nc" id="L99">                executeSQLStatements(sql, fileName, false);</span>
<span class="nc" id="L100">            } catch (SQLException | JSQLParserException e) {</span>
<span class="nc" id="L101">                LOGGER.debug(&quot;Error on clean-up operation: {}&quot;, e.getMessage(), e);</span>
<span class="nc" id="L102">            }</span>
<span class="nc" id="L103">        };</span>
<span class="nc" id="L104">        return this;</span>
    }

    public void bindRowValues(
        PreparedStatement statement,
        DataSet dataSet,
        boolean nullControl
    ) throws SQLException {
<span class="fc" id="L112">        bindRowValues(statement, dataSet, dataSet.columns(), nullControl);</span>
<span class="fc" id="L113">    }</span>


    public void bindRowValues(
        PreparedStatement statement,
        DataSet dataSet,
        String[] columns,
        boolean nullControl
    ) throws SQLException {
<span class="fc" id="L122">        bindRowValues(statement, dataSet, columns, 0, nullControl);</span>
<span class="fc" id="L123">    }</span>

    public void bindRowValues(
            PreparedStatement statement,
            DataSet dataSet,
            String[] columns,
            int startIndex,
            boolean nullControl
    ) throws SQLException {
        // if nullControl = true, the statement will contain 2 entries of the same
        // parameters
<span class="fc bfc" id="L134" title="All 2 branches covered.">        int factor = nullControl ? 2 : 1;</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (int i = 0; i &lt; columns.length; i++) {</span>
<span class="fc" id="L136">            statement.setObject((startIndex + i) * factor + 1, dataSet.rowValue(columns[i]));</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            if (nullControl) {</span>
<span class="fc" id="L138">                statement.setObject((startIndex + i) * factor + 2, dataSet.rowValue(columns[i]));</span>
            }
        }
<span class="fc" id="L141">    }</span>


    private PreparedStatement createRowStatement(
        CharSequence sql,
        DataSet dataSet,
        boolean nullControl
    ) throws SQLException {
<span class="fc" id="L149">        PreparedStatement statement = connection().prepareStatement(sql.toString());</span>
<span class="fc" id="L150">        bindRowValues(statement, dataSet, nullControl);</span>
<span class="fc" id="L151">        return statement;</span>
    }


    private &lt;T&gt; T extractSingleResult(PreparedStatement statement, Class&lt;T&gt; type)
    throws SQLException {
<span class="fc" id="L157">        try (ResultSet result = statement.executeQuery()) {</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">            if (!result.next()) {</span>
<span class="nc" id="L159">                return null;</span>
            }
<span class="fc" id="L161">            return result.getObject(1, type);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        }</span>
    }

    private Optional&lt;String[]&gt; detectPrimaryKey(String table) {
        try {
<span class="fc" id="L167">            DatabaseMetaData metadata = connection().getMetaData();</span>
<span class="fc" id="L168">            ArrayList&lt;String&gt; primaryKeys = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L169">            ResultSet resultSet = metadata.getPrimaryKeys(catalog(), schema(), caseSensitivity.format(table));</span>
<span class="pc bpc" id="L170" title="1 of 4 branches missed.">            while (resultSet != null &amp;&amp; resultSet.next()) {</span>
<span class="fc" id="L171">                primaryKeys.add(resultSet.getString(&quot;COLUMN_NAME&quot;));</span>
            }
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">            return primaryKeys.isEmpty() ? Optional.empty() : Optional.of(primaryKeys.toArray(new String[0]));</span>
<span class="nc" id="L174">        } catch (Exception e) {</span>
<span class="nc" id="L175">            throw new KukumoException(e);</span>
        }
    }


    private Map&lt;String, Integer&gt; collectNonNullableColumns(String table) {
        try {
<span class="nc" id="L182">            DatabaseMetaData metadata = connection().getMetaData();</span>
<span class="nc" id="L183">            Map&lt;String, Integer&gt; nonNullableColumns = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L184">            ResultSet resultSet = metadata.getColumns(catalog(), schema(), caseSensitivity.format(table), null);</span>
<span class="nc bnc" id="L185" title="All 4 branches missed.">            while (resultSet != null &amp;&amp; resultSet.next()) {</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                if (resultSet.getInt(&quot;NULLABLE&quot;) == DatabaseMetaData.attributeNoNulls) {</span>
<span class="nc" id="L187">                    nonNullableColumns</span>
<span class="nc" id="L188">                        .put(resultSet.getString(&quot;COLUMN_NAME&quot;), resultSet.getInt(&quot;DATA_TYPE&quot;));</span>
                }
            }
<span class="nc" id="L191">            return nonNullableColumns;</span>
<span class="nc" id="L192">        } catch (Exception e) {</span>
<span class="nc" id="L193">            throw new KukumoException(e);</span>
        }
    }


    private void assertCount(
        PreparedStatement statement,
        Assertion&lt;Long&gt; matcher
    ) throws SQLException {
<span class="fc" id="L202">        Assertion.assertThat(extractSingleResult(statement, Long.class), matcher);</span>
<span class="fc" id="L203">    }</span>


    public void assertCountRowsInTableByColumns(
        Assertion&lt;Long&gt; matcher,
        String table,
        String[] columns,
        Object[] values
    ) throws SQLException {
<span class="fc" id="L212">        String sql = parser.sqlSelectCountFrom(table, columns).toString();</span>
<span class="fc" id="L213">        try (PreparedStatement statement =  createRowStatement(</span>
            sql,
<span class="fc" id="L215">            new InlineDataSet(table, columns, values, nullSymbol.get()),</span>
            true
        )) {
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">            if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L219">                LOGGER.trace(&quot;[SQL] {sql}  | {}&quot;, sql, mapValues(columns, values));</span>
            }
<span class="fc" id="L221">            assertCount(statement, matcher);</span>
<span class="nc" id="L222">        } catch (SQLException e) {</span>
<span class="nc" id="L223">            LOGGER.error(&quot;[SQL] {sql} | {}&quot;, sql, mapValues(columns, values));</span>
<span class="nc" id="L224">            throw e;</span>
<span class="fc" id="L225">        }</span>
<span class="fc" id="L226">    }</span>


    public void assertCountRowsInTableByClause(
        Assertion&lt;Long&gt; matcher,
        String table,
        String clause
    ) throws SQLException, JSQLParserException {
<span class="fc" id="L234">        String sql = parser.sqlSelectCountFrom(table, clause).toString();</span>
<span class="fc" id="L235">        try (PreparedStatement statement = createRowStatement(</span>
            sql,
            new EmptyDataSet(table),
            false
        )) {
<span class="fc" id="L240">            LOGGER.trace(&quot;[SQL] {sql}&quot;, sql);</span>
<span class="fc" id="L241">            assertCount(statement, matcher);</span>
<span class="nc" id="L242">        }  catch (SQLException e) {</span>
<span class="nc" id="L243">            LOGGER.error(&quot;[SQL] {sql}&quot;, sql);</span>
<span class="nc" id="L244">            throw e;</span>
<span class="fc" id="L245">        }</span>
<span class="fc" id="L246">    }</span>


    public long executeSQLStatements(String sql, boolean addCleanUpOperation) throws SQLException, JSQLParserException {
<span class="nc" id="L250">        return executeSQLStatements(sql, null, addCleanUpOperation);</span>
    }

    public long executeSQLStatements(
            String sql,
            String scriptFileName,
            boolean addCleanUpOperation
    ) throws SQLException, JSQLParserException {
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (scriptFileName != null) {</span>
<span class="nc" id="L259">            LOGGER.debug(&quot;Executing SQL script from '{}'...&quot;, scriptFileName);</span>
        } else {
<span class="nc" id="L261">            LOGGER.debug(&quot;Executing SQL script...&quot;);</span>
        }

<span class="nc" id="L264">        List&lt;net.sf.jsqlparser.statement.Statement&gt; statements = parser.parseStatements(sql);</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        if (addCleanUpOperation) {</span>
<span class="nc" id="L266">            statements.forEach(this::sqlCleanUpOperations);</span>
        }

<span class="nc" id="L269">        long count = 0;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        for (net.sf.jsqlparser.statement.Statement statementLine : statements) {</span>
<span class="nc" id="L271">            try (PreparedStatement statement = connection().prepareStatement(statementLine.toString(), Statement.RETURN_GENERATED_KEYS)) {</span>
<span class="nc" id="L272">                statement.addBatch();</span>
<span class="nc" id="L273">                LOGGER.trace(&quot;[SQL] {sql}&quot;, statementLine);</span>
<span class="nc" id="L274">                count = count + countResults(statement.executeBatch());</span>
<span class="nc bnc" id="L275" title="All 4 branches missed.">                if (statementLine instanceof Insert &amp;&amp; addCleanUpOperation) {</span>
<span class="nc" id="L276">                    DataSet pks = getGeneratedKeys(statement, (Insert) statementLine);</span>
<span class="nc" id="L277">                    cleanUpOperations.addFirst(deleteDataSetRunner(pks));</span>
                }
<span class="nc" id="L279">            } catch (SQLException e) {</span>
<span class="nc" id="L280">                statements.forEach(statement -&gt; LOGGER.error(&quot;[SQL] {sql}&quot;, statement));</span>
<span class="nc" id="L281">                throw e;</span>
<span class="nc" id="L282">            }</span>
<span class="nc" id="L283">        }</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (scriptFileName != null) {</span>
<span class="nc" id="L285">            LOGGER.debug(&quot;Executed SQL script '{}'; {} rows affected&quot;, scriptFileName, count);</span>
        } else {
<span class="nc" id="L287">            LOGGER.debug(&quot;Executed SQL script; {} rows affected&quot;, count);</span>
        }
<span class="nc" id="L289">        return count;</span>
    }

    private DataSet getGeneratedKeys(Statement statement, Insert insert) throws SQLException {
<span class="nc" id="L293">        String[] columns = insert.getColumns().stream().map(Objects::toString).toArray(String[]::new);</span>
<span class="nc" id="L294">        String table = insert.getTable().getName();</span>
<span class="nc" id="L295">        String[] pkColumns = primaryKey(insert.getTable().getName())</span>
<span class="nc" id="L296">                .orElseThrow(() -&gt; {</span>
<span class="nc" id="L297">                    String message = String.format(&quot;Cannot determine primary key for table '%s'. Please, disable the '%s' property.&quot;,</span>
<span class="nc" id="L298">                            caseSensitivity.format(table), DatabaseConfigContributor.DATABASE_ENABLE_CLEANUP_UPON_COMPLETION);</span>
<span class="nc" id="L299">                    return new KukumoException(message);</span>
                });
<span class="nc" id="L301">        String[] pkValues = new String[pkColumns.length];</span>
<span class="nc" id="L302">        boolean pkValuesValid = false;</span>

<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (Arrays.asList(columns).containsAll(Arrays.asList(pkColumns))) {</span>
<span class="nc" id="L305">            pkValuesValid = extractPrimaryKeyFromInsert(insert, columns, pkColumns, pkValues);</span>
        }

<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (!pkValuesValid) {</span>
<span class="nc" id="L309">            ResultSet rs = statement.getGeneratedKeys();</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">            while (rs.next()) {</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                for (int i = 0; i &lt; pkColumns.length; i++) {</span>
<span class="nc" id="L312">                    pkValues[i] = rs.getString(i+1);</span>
                }
            }
        }
<span class="nc" id="L316">        return new InlineDataSet(insert.getTable().getName(), pkColumns, pkValues, nullSymbol.get());</span>
    }



    private boolean extractPrimaryKeyFromInsert(Insert insert, String[] columns, String[] pkColumns, String[] pkValues) {
<span class="nc" id="L322">        List&lt;Expression&gt; expressions = ((ExpressionList) insert.getItemsList()).getExpressions();</span>
        // if any of the expressions is a parameter, it can't be sued
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (expressions.stream().anyMatch(JdbcParameter.class::isInstance)) {</span>
<span class="nc" id="L325">            return false;</span>
        }
<span class="nc" id="L327">        String[] values = expressions.stream().map(parser::extractValue).toArray(String[]::new);</span>
<span class="nc" id="L328">        int n = 0;</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        for (int i = 0; i &lt; columns.length; i++) {</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">            if (Arrays.asList(pkColumns).contains(columns[i])) {</span>
<span class="nc" id="L331">                pkValues[n] = values[i];</span>
<span class="nc" id="L332">                n++;</span>
            }
        }
<span class="nc" id="L335">        return true;</span>
    }


    private void sqlCleanUpOperations(net.sf.jsqlparser.statement.Statement statement) {
<span class="nc" id="L340">        statement.accept(new StatementVisitorAdapter() {</span>
            @Override
            public void visit(Delete delete) {
<span class="nc" id="L343">                cleanUpOperations.addFirst(parser.toSelect(delete)</span>
<span class="nc" id="L344">                        .map(select -&gt; executeSelect(select))</span>
<span class="nc" id="L345">                        .map(dataSet -&gt; insertDataSetRunner(dataSet))</span>
<span class="nc" id="L346">                        .get());</span>
<span class="nc" id="L347">            }</span>

            @Override
            public void visit(Update update) {
<span class="nc" id="L351">                cleanUpOperations.addFirst(parser.toSelect(update)</span>
<span class="nc" id="L352">                        .map(select -&gt; executeSelect(select))</span>
<span class="nc" id="L353">                        .map(dataSet -&gt; updateDataSetRunner(dataSet, update))</span>
<span class="nc" id="L354">                        .get());</span>
<span class="nc" id="L355">            }</span>
        });
<span class="nc" id="L357">    }</span>

    public DataSet executeSelect(Select select) {
<span class="nc" id="L360">        try (Statement statement = connection().createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {</span>
<span class="nc" id="L361">            LOGGER.trace(&quot;[SQL] {sql}&quot;, select);</span>
<span class="nc" id="L362">            ResultSet resultSet = statement.executeQuery(select.toString());</span>
<span class="nc" id="L363">            String table = ((PlainSelect) select.getSelectBody()).getFromItem().toString();</span>
<span class="nc" id="L364">            return read(table, resultSet);</span>
<span class="nc" id="L365">        } catch (SQLException e) {</span>
<span class="nc" id="L366">            LOGGER.error(&quot;[SQL] {sql}&quot;, select);</span>
<span class="nc" id="L367">            throw new RuntimeException(e);</span>
        }
    }

    public DataSet executeSelect(Select select, DataSet dataSet, String[] columns) throws SQLException {
<span class="nc" id="L372">        try (PreparedStatement statement = connection()</span>
<span class="nc" id="L373">                .prepareStatement(select.toString(), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {</span>
<span class="nc" id="L374">            traceSQL(select.toString(), dataSet);</span>
<span class="nc" id="L375">            bindRowValues(statement, dataSet, columns, true);</span>
<span class="nc" id="L376">            ResultSet resultSet = statement.executeQuery();</span>
<span class="nc" id="L377">            return read(dataSet.table(), resultSet);</span>
<span class="nc" id="L378">        } catch (SQLException e) {</span>
<span class="nc" id="L379">            LOGGER.error(&quot;[SQL] {sql} | {}&quot;, select, dataSet.rowAsMap());</span>
<span class="nc" id="L380">            throw e;</span>
        }
    }

    private DataSet read(String table, ResultSet resultSet) throws SQLException {
<span class="nc" id="L385">        ResultSetMetaData md = resultSet.getMetaData();</span>
<span class="nc" id="L386">        String[] columns = new String[md.getColumnCount()];</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">        for (int i = 0; i &lt; columns.length; ++i) {</span>
<span class="nc" id="L388">            columns[i] = md.getColumnName(i + 1);</span>
        }
<span class="nc" id="L390">        List&lt;String[]&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        while (resultSet.next()) {</span>
<span class="nc" id="L392">            String[] row = new String[columns.length];</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            for (int i = 0; i &lt; columns.length; i++) {</span>
<span class="nc" id="L394">                row[i] = Optional.ofNullable(resultSet.getString(i + 1)).map(String::trim).orElse(null);</span>
            }
<span class="nc" id="L396">            values.add(row);</span>
<span class="nc" id="L397">        }</span>
<span class="nc" id="L398">        return new MapDataSet(table, columns, values.toArray(new String[values.size()][]), nullSymbol.get());</span>
    }

    public long insertDataSet(
        DataSet dataSet,
        boolean addCleanUpOperation
    ) throws SQLException, IOException {
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L406">            LOGGER.debug(</span>
                &quot;Inserting rows in table {} from {}...&quot;,
<span class="nc" id="L408">                caseSensitivity.format(dataSet.table()),</span>
<span class="nc" id="L409">                dataSet.origin()</span>
            );
        }
<span class="fc" id="L412">        Insert insert = parser.sqlInsertIntoValues(dataSet.copy());</span>
<span class="fc" id="L413">        try (PreparedStatement statement = connection().prepareStatement(insert.toString(), Statement.RETURN_GENERATED_KEYS)) {</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">            while (dataSet.nextRow()) {</span>
<span class="fc" id="L415">                bindRowValues(statement, dataSet, false);</span>
<span class="fc" id="L416">                statement.addBatch();</span>
<span class="fc" id="L417">                traceSQL(insert.toString(), dataSet);</span>
            }
<span class="fc" id="L419">            long count = countResults(statement.executeBatch());</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">            if (addCleanUpOperation) {</span>
<span class="nc" id="L421">                DataSet pks = getGeneratedKeys(statement, insert);</span>
<span class="nc" id="L422">                cleanUpOperations.addFirst(deleteDataSetRunner(pks));</span>
            }
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">            if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L425">                LOGGER.debug(</span>
                    &quot;Inserted {} rows in table {} from {}&quot;,
<span class="nc" id="L427">                    count,</span>
<span class="nc" id="L428">                    caseSensitivity.format(dataSet.table()),</span>
<span class="nc" id="L429">                    dataSet.origin()</span>
                );
            }
<span class="fc" id="L432">            dataSet.close();</span>
<span class="fc" id="L433">            return count;</span>
        }
    }

    public long updateDataSet(
            DataSet beforeDataSet,
            DataSet afterDataSet
    ) throws SQLException, IOException {
<span class="nc bnc" id="L441" title="All 2 branches missed.">        if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L442">            LOGGER.debug(</span>
                    &quot;Updating rows in table {} from {}...&quot;,
<span class="nc" id="L444">                    caseSensitivity.format(beforeDataSet.table()),</span>
<span class="nc" id="L445">                    beforeDataSet.origin()</span>
            );
        }
<span class="nc" id="L448">        String[] primaryKey = primaryKey(beforeDataSet.table())</span>
<span class="nc" id="L449">                .orElseThrow(() -&gt; {</span>
<span class="nc" id="L450">                    String message = String.format(&quot;Cannot determine primary key for table '%s'. Primary key is needed in this step.&quot;,</span>
<span class="nc" id="L451">                            caseSensitivity.format(beforeDataSet.table()));</span>
<span class="nc" id="L452">                    return new KukumoException(message);</span>
                });

<span class="nc" id="L455">        Update sql = parser.sqlUpdateSet(beforeDataSet, primaryKey);</span>

        //list to get ordered column replacements in prepared statement
<span class="nc" id="L458">        List&lt;String&gt; setColumns = sql.getColumns().stream().map(Object::toString).collect(Collectors.toCollection(LinkedList::new));</span>
<span class="nc" id="L459">        DataSet whereDataSet = merge(beforeDataSet.copy(), afterDataSet.copy());</span>

<span class="nc" id="L461">        try (PreparedStatement statement = connection().prepareStatement(sql.toString())) {</span>
<span class="nc bnc" id="L462" title="All 4 branches missed.">            while (beforeDataSet.nextRow() &amp;&amp; whereDataSet.nextRow()) {</span>
<span class="nc" id="L463">                bindRowValues(statement, beforeDataSet, setColumns.toArray(String[]::new), false);</span>
<span class="nc" id="L464">                bindRowValues(statement, whereDataSet, primaryKey, setColumns.size(), false);</span>
<span class="nc" id="L465">                statement.addBatch();</span>
<span class="nc" id="L466">                traceSQL(sql.toString(), beforeDataSet, whereDataSet);</span>
            }
<span class="nc" id="L468">            long count = countResults(statement.executeBatch());</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">            if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L470">                LOGGER.debug(</span>
                        &quot;Updated {} rows in table {} from {}&quot;,
<span class="nc" id="L472">                        count,</span>
<span class="nc" id="L473">                        caseSensitivity.format(beforeDataSet.table()),</span>
<span class="nc" id="L474">                        beforeDataSet.origin()</span>
                );
            }
<span class="nc" id="L477">            return count;</span>
        }
    }

    private DataSet merge(DataSet dataSet1, DataSet dataSet2) {
<span class="nc" id="L482">        Set&lt;String&gt; aux = new HashSet&lt;&gt;(Set.of(dataSet1.columns()));</span>
<span class="nc" id="L483">        aux.addAll(Set.of(dataSet1.columns()));</span>
<span class="nc" id="L484">        String[] columns = aux.toArray(String[]::new);</span>
<span class="nc" id="L485">        List&lt;String[]&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L486">        dataSet2.nextRow();</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">        while (dataSet1.nextRow()) {</span>
<span class="nc" id="L488">            String[] row = new String[columns.length];</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">            for (int i = 0; i &lt; columns.length; i++) {</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                row[i] = Optional.ofNullable((dataSet2.containColumns(columns[i]) ? dataSet2 : dataSet1).rowValue(columns[i]))</span>
<span class="nc" id="L491">                        .map(Object::toString).orElse(null);</span>
            }
<span class="nc" id="L493">            values.add(row);</span>
<span class="nc" id="L494">        }</span>
<span class="nc" id="L495">        return new MapDataSet(dataSet1.table(), columns, values.toArray(String[][]::new), nullSymbol.get());</span>
    }

    private Runnable deleteDataSetRunner(final DataSet dataSet) {
<span class="nc" id="L499">        return () -&gt; {</span>
            try {
<span class="nc" id="L501">                deleteDataSet(dataSet, false);</span>
<span class="nc" id="L502">            } catch (SQLException | IOException e) {</span>
<span class="nc" id="L503">                LOGGER.debug(&quot;Error on clean-up operation: {}&quot;, e.getMessage(), e);</span>
<span class="nc" id="L504">            }</span>
<span class="nc" id="L505">        };</span>
    }

    private Runnable insertDataSetRunner(final DataSet dataSet) {
<span class="nc" id="L509">        return () -&gt; {</span>
            try {
<span class="nc" id="L511">                insertDataSet(dataSet, false);</span>
<span class="nc" id="L512">            } catch (SQLException | IOException e) {</span>
<span class="nc" id="L513">                LOGGER.debug(&quot;Error on clean-up operation: {}&quot;, e.getMessage(), e);</span>
<span class="nc" id="L514">            }</span>
<span class="nc" id="L515">        };</span>
    }

    private Runnable updateDataSetRunner(final DataSet dataSet, Update update) {
<span class="nc" id="L519">        return () -&gt; {</span>
            try {
<span class="nc" id="L521">                List&lt;String&gt; columns = update.getColumns().stream()</span>
<span class="nc" id="L522">                        .map(Column::getColumnName)</span>
<span class="nc" id="L523">                        .collect(Collectors.toCollection(LinkedList::new));</span>
<span class="nc" id="L524">                Object[] values = update.getExpressions().stream().map(parser::extractValue).toArray();</span>
<span class="nc" id="L525">                DataSet newDataSet = new InlineDataSet(update.getTable().getName(),</span>
<span class="nc" id="L526">                        columns.toArray(String[]::new), values, nullSymbol.get());</span>

<span class="nc" id="L528">                updateDataSet(dataSet, newDataSet);</span>
<span class="nc" id="L529">            } catch (SQLException | IOException e) {</span>
<span class="nc" id="L530">                LOGGER.debug(&quot;Error on clean-up operation: {}&quot;, e.getMessage(), e);</span>
<span class="nc" id="L531">            }</span>
<span class="nc" id="L532">        };</span>
    }

    public long deleteDataSet(DataSet dataSet, boolean addCleanUpOperation) throws SQLException, IOException {
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">        if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L537">            LOGGER.debug(&quot;Deleting rows in table {} from {}...&quot;, caseSensitivity.format(dataSet.table()), dataSet.origin());</span>
        }

<span class="fc" id="L540">        Optional&lt;String[]&gt; primaryKey = primaryKey(dataSet.table()).filter(k -&gt; addCleanUpOperation);</span>
<span class="fc" id="L541">        String[] columns = primaryKey.orElse(dataSet.columns());</span>
<span class="fc" id="L542">        Delete sql = parser.sqlDeleteFrom(dataSet.table(), columns);</span>
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        if (addCleanUpOperation) {</span>
<span class="nc" id="L544">            Optional&lt;Select&gt; select = parser.toSelect(sql);</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">            if (select.isPresent()) {</span>

<span class="nc" id="L547">                DataSet data = executeSelect(select.get(), dataSet, columns);</span>
<span class="nc" id="L548">                cleanUpOperations.addFirst(insertDataSetRunner(data));</span>
            }
        }
<span class="fc" id="L551">        try (PreparedStatement statement = connection().prepareStatement(sql.toString())) {</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">            while (dataSet.nextRow()) {</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">                if (primaryKey.isPresent()) {</span>
<span class="nc" id="L554">                    bindRowValues(statement, dataSet, primaryKey.get(), true);</span>
                } else {
<span class="fc" id="L556">                    bindRowValues(statement, dataSet, true);</span>
                }
<span class="fc" id="L558">                statement.addBatch();</span>
<span class="fc" id="L559">                traceSQL(sql.toString(), dataSet);</span>
            }
<span class="fc" id="L561">            long count = countResults(statement.executeBatch());</span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">            if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L563">                LOGGER.debug(</span>
                    &quot;Deleted {} rows in table {} from {}&quot;,
<span class="nc" id="L565">                    count,</span>
<span class="nc" id="L566">                    caseSensitivity.format(dataSet.table()),</span>
<span class="nc" id="L567">                    dataSet.origin()</span>
                );
            }
<span class="fc" id="L570">            dataSet.close();</span>
<span class="fc" id="L571">            return count;</span>

        }
    }


    public void truncateTable(String table) throws SQLException {
<span class="fc" id="L578">        LOGGER.debug(&quot;Deleting all rows in table {}...&quot;, table);</span>
<span class="fc" id="L579">        try (Statement truncate = connection().createStatement()) {</span>
<span class="fc" id="L580">            truncate.execute(&quot;truncate table &quot; + table);</span>
<span class="fc" id="L581">            LOGGER.debug(&quot;Deleted all rows in table {}&quot;, table);</span>
<span class="nc" id="L582">        } catch (SQLException e) {</span>
            // truncate may not work in every situation, try to do a delete instead
<span class="nc" id="L584">            try (Statement delete = connection().createStatement()) {</span>
<span class="nc" id="L585">                delete.execute(&quot;delete from &quot; + table);</span>
<span class="nc" id="L586">                LOGGER.debug(&quot;Deleted all rows in table {}&quot;, table);</span>
            }
<span class="fc" id="L588">        }</span>
<span class="fc" id="L589">    }</span>


    public long insertMultiDataSet(
        MultiDataSet multiDataSet,
        boolean addCleanUpOperation
    ) throws SQLException, IOException {
<span class="nc" id="L596">        long count = 0;</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">        for (DataSet dataSet : multiDataSet) {</span>
<span class="nc" id="L598">            count += insertDataSet(dataSet, false); // adding the complete multidataset as cleanup</span>
                                                    // operation
<span class="nc" id="L600">        }</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">        if (addCleanUpOperation) {</span>
<span class="nc" id="L602">            multiDataSet.copy().forEach(ds -&gt; cleanUpOperations.addFirst(deleteDataSetRunner(ds)));</span>
        }
<span class="nc" id="L604">        return count;</span>
    }


    public long deleteMultiDataSet(MultiDataSet multiDataSet, boolean addCleanUpOperation) throws SQLException, IOException {
<span class="nc" id="L609">        long count = 0;</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">        for (DataSet dataSet : multiDataSet) {</span>
<span class="nc" id="L611">            count += deleteDataSet(dataSet, addCleanUpOperation);</span>
<span class="nc" id="L612">        }</span>
<span class="nc" id="L613">        return count;</span>
    }


    public void assertDataSetExists(DataSet dataSet) throws SQLException {
<span class="nc" id="L618">        String sql = parser.sqlSelectFrom(dataSet.table(), dataSet.columns()).toString();</span>
<span class="nc" id="L619">        try (PreparedStatement statement = connection().prepareStatement(sql)) {</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">            while (dataSet.nextRow()) {</span>
<span class="nc" id="L621">                bindRowValues(statement, dataSet, true);</span>
<span class="nc" id="L622">                assertRowExists(dataSet, statement);</span>
            }
        }
<span class="nc" id="L625">    }</span>


    public void assertDataSetNotExists(DataSet dataSet) throws SQLException {
<span class="nc" id="L629">        String sql = parser.sqlSelectFrom(dataSet.table(), dataSet.columns()).toString();</span>
<span class="nc" id="L630">        try (PreparedStatement statement = connection().prepareStatement(sql)) {</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">            while (dataSet.nextRow()) {</span>
<span class="nc" id="L632">                bindRowValues(statement, dataSet, true);</span>
<span class="nc" id="L633">                assertRowNotExists(dataSet, statement);</span>
            }
        }
<span class="nc" id="L636">    }</span>


    private void assertRowExists(DataSet dataSet, PreparedStatement statement) throws SQLException {
<span class="nc" id="L640">        try (ResultSet resultSet = statement.executeQuery()) {</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">            if (!resultSet.next()) {</span>
<span class="nc" id="L642">                Assertions.fail(logRowNotFound(dataSet));</span>
            }
        }
<span class="nc" id="L645">    }</span>


    private void assertRowNotExists(
        DataSet dataSet,
        PreparedStatement statement
    ) throws SQLException {
<span class="nc" id="L652">        try (ResultSet resultSet = statement.executeQuery()) {</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">            if (resultSet.next()) {</span>
<span class="nc" id="L654">                Assertions.fail(</span>
<span class="nc" id="L655">                    String.format(</span>
                        &quot;Expected row %s not to exist in table %s but it does&quot;,
<span class="nc" id="L657">                        dataSet.rowAsMap(),</span>
<span class="nc" id="L658">                        caseSensitivity.format(dataSet.table())</span>
                    )
                );
            }
        }
<span class="nc" id="L663">    }</span>


    public void assertCountRowsInTableByDataSet(
        DataSet dataSet,
        Assertion&lt;Long&gt; matcher
    ) throws SQLException {
<span class="nc" id="L670">        String sql = parser.sqlSelectCountFrom(dataSet.table(), dataSet.columns()).toString();</span>
<span class="nc" id="L671">        long count = 0;</span>
<span class="nc" id="L672">        try (PreparedStatement statement = connection().prepareStatement(sql)) {</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">            while (dataSet.nextRow()) {</span>
<span class="nc" id="L674">                bindRowValues(statement, dataSet, true);</span>
<span class="nc" id="L675">                count += extractSingleResult(statement, Long.class);</span>
            }
<span class="nc" id="L677">        } catch (SQLException e) {</span>
<span class="nc" id="L678">            LOGGER.error(&quot;[SQL] {sql}&quot;,sql);</span>
<span class="nc" id="L679">        }</span>
<span class="nc" id="L680">        Assertion.assertThat(count, matcher);</span>
<span class="nc" id="L681">    }</span>


    public void assertMultiDataSetExists(MultiDataSet multiDataSet) throws SQLException {
<span class="nc bnc" id="L685" title="All 2 branches missed.">        for (DataSet dataSet : multiDataSet) {</span>
<span class="nc" id="L686">            assertDataSetExists(dataSet);</span>
<span class="nc" id="L687">        }</span>
<span class="nc" id="L688">    }</span>


    public void assertMultiDataSetNotExists(MultiDataSet multiDataSet) throws SQLException {
<span class="nc bnc" id="L692" title="All 2 branches missed.">        for (DataSet dataSet : multiDataSet) {</span>
<span class="nc" id="L693">            assertDataSetNotExists(dataSet);</span>
<span class="nc" id="L694">        }</span>
<span class="nc" id="L695">    }</span>


    private String logRowNotFound(DataSet dataSet) throws SQLException {
<span class="nc" id="L699">        String message = &quot;Expected row &quot; + dataSet.rowAsMap() + &quot; existed in table &quot; + dataSet</span>
<span class="nc" id="L700">            .table();</span>
        // try to locate the actual row values according the primary keys
<span class="nc" id="L702">        Optional&lt;String[]&gt; primaryKey = primaryKey(dataSet.table())</span>
<span class="nc" id="L703">                .filter(dataSet::containColumns);</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">        if (primaryKey.isEmpty()) {</span>
<span class="nc" id="L705">            message += &quot; but was not found&quot;;</span>
        } else {
<span class="nc" id="L707">            message = logRowNotFoundCompared(dataSet, message, primaryKey.get());</span>
        }
<span class="nc" id="L709">        return message;</span>
    }


    private String logRowNotFoundCompared(
        DataSet dataSet,
        String message,
        String[] primaryKey
    ) throws SQLException {
<span class="nc" id="L718">        String sql = parser.sqlSelectFrom(dataSet.table(), primaryKey).toString();</span>
<span class="nc" id="L719">        try (PreparedStatement statement = connection().prepareStatement(sql)) {</span>
<span class="nc" id="L720">            bindRowValues(statement, dataSet, primaryKey, true);</span>
<span class="nc" id="L721">            try (ResultSet resultSet = statement.executeQuery()) {</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">                if (resultSet.next()) {</span>
<span class="nc" id="L723">                    message += &quot; but was actually &quot; + mapValues(dataSet.columns(), resultSet);</span>
                }
            }
        }
<span class="nc" id="L727">        return message;</span>
    }


    public void cleanUp() {
<span class="fc" id="L732">        LOGGER.debug(&quot;Performing clean-up operations...&quot;);</span>
<span class="fc" id="L733">        Optional.ofNullable(manualCleanup).ifPresent(Runnable::run);</span>
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">        for (Runnable cleanUp : cleanUpOperations) {</span>
<span class="nc" id="L735">            cleanUp.run();</span>
<span class="nc" id="L736">        }</span>
<span class="fc" id="L737">        LOGGER.debug(&quot;Clean-up finished&quot;);</span>
<span class="fc" id="L738">    }</span>


    private long countResults(int[] results) {
<span class="fc bfc" id="L742" title="All 2 branches covered.">        return IntStream.of(results).filter(count -&gt; count &gt; 0).count();</span>
    }


    public Optional&lt;String[]&gt; primaryKey(String table) {
<span class="fc" id="L747">        String[] keys = primaryKeyCache.computeIfAbsent(table, t -&gt; detectPrimaryKey(t).orElse(null));</span>
<span class="fc" id="L748">        return Optional.ofNullable(keys);</span>
    }

    public Map&lt;String, Integer&gt; nonNullableColumns(String table) {
<span class="nc" id="L752">        return nonNullabeColumnCache.computeIfAbsent(table, this::collectNonNullableColumns);</span>
    }


    private Map&lt;String, Object&gt; mapValues(String[] columns, Object[] values) {
<span class="nc" id="L757">        Map&lt;String, Object&gt; log = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">        for (int i = 0; i &lt; columns.length; i++) {</span>
<span class="nc" id="L759">            log.put(columns[i], values[i]);</span>
        }
<span class="nc" id="L761">        return log;</span>
    }


    private Map&lt;String, Object&gt; mapValues(
        String[] columns,
        ResultSet resultSet
    ) throws SQLException {
<span class="nc" id="L769">        Map&lt;String, Object&gt; log = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">        for (String column : columns) {</span>
<span class="nc" id="L771">            log.put(column, resultSet.getObject(column));</span>
        }
<span class="nc" id="L773">        return log;</span>
    }


    private void traceSQL(String sql, DataSet... dataSet) {
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">        if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L779">            LOGGER.trace(&quot;[SQL] {sql} | {}&quot;, sql, Stream.of(dataSet).map(DataSet::rowAsMap).collect(Collectors.toList()));</span>
        }
<span class="fc" id="L781">    }</span>

    private String catalog() {
        try {
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">            if (connectionParameters.catalog() != null) {</span>
<span class="nc" id="L786">                return connectionParameters.catalog();</span>
            }
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">            if (connection().getCatalog() != null) {</span>
<span class="fc" id="L789">                return connection().getCatalog();</span>
            }
<span class="nc" id="L791">            return null;</span>
<span class="nc" id="L792">        } catch (SQLException e) {</span>
<span class="nc" id="L793">            LOGGER.trace(e.toString());</span>
<span class="nc" id="L794">            return null;</span>
        }
    }



    private String schema() {
        try {
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">            if (connectionParameters.schema() != null) {</span>
<span class="nc" id="L803">                return connectionParameters.schema();</span>
            }
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">            if (connection().getSchema() != null) {</span>
<span class="fc" id="L806">                return connection().getSchema();</span>
            }
<span class="nc" id="L808">            return null;</span>
<span class="nc" id="L809">        } catch (SQLException e) {</span>
<span class="nc" id="L810">            LOGGER.trace(e.toString());</span>
<span class="nc" id="L811">            return null;</span>
        }
    }




}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>