<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlanNodeBuilderRules.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Kukumo::CORE</a> &gt; <a href="index.source.html" class="el_package">iti.kukumo.core.plan</a> &gt; <span class="el_source">PlanNodeBuilderRules.java</span></div><h1>PlanNodeBuilderRules.java</h1><pre class="source lang-java linenums">/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

/**
 * @author Luis IÃ±esta Gelabert - linesta@iti.es | luiinge@gmail.com
 */
package iti.kukumo.core.plan;


import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.LongPredicate;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import iti.kukumo.api.KukumoException;
import iti.kukumo.api.plan.NodeType;
import iti.kukumo.api.plan.PlanNodeBuilder;


<span class="nc" id="L30">public class PlanNodeBuilderRules {</span>

<span class="fc" id="L32">    private enum RuleMethod {</span>
<span class="fc" id="L33">        ALL((list, consumer) -&gt; list.forEach(consumer)),</span>
<span class="pc" id="L34">        FIRST((list, consumer) -&gt; list.stream().findAny().ifPresent(consumer));</span>

        private final BiConsumer&lt;List&lt;PlanNodeBuilder&gt;, Consumer&lt;PlanNodeBuilder&gt;&gt; consumer;


<span class="fc" id="L39">        RuleMethod(BiConsumer&lt;List&lt;PlanNodeBuilder&gt;, Consumer&lt;PlanNodeBuilder&gt;&gt; consumer) {</span>
<span class="fc" id="L40">            this.consumer = consumer;</span>
<span class="fc" id="L41">        }</span>


        public void apply(List&lt;PlanNodeBuilder&gt; list, Consumer&lt;PlanNodeBuilder&gt; consumer) {
<span class="fc" id="L45">            this.consumer.accept(list, consumer);</span>
<span class="fc" id="L46">        }</span>
    }


    public interface PlanNodeBuilderRule {

        void apply(PlanNodeBuilder node) throws KukumoException;
    }


    public static class PlanNodeBuilderRuleConsumer implements PlanNodeBuilderRule {

        protected final Predicate&lt;PlanNodeBuilder&gt; predicate;
        protected final Consumer&lt;PlanNodeBuilder&gt; consumer;
        protected final RuleMethod method;


        private PlanNodeBuilderRuleConsumer(
                        Predicate&lt;PlanNodeBuilder&gt; predicate,
                        Consumer&lt;PlanNodeBuilder&gt; consumer,
                        RuleMethod method
<span class="fc" id="L67">        ) {</span>
<span class="fc" id="L68">            this.predicate = predicate;</span>
<span class="fc" id="L69">            this.consumer = consumer;</span>
<span class="fc" id="L70">            this.method = method;</span>
<span class="fc" id="L71">        }</span>


        public PlanNodeBuilderRuleConsumer perform(Consumer&lt;PlanNodeBuilder&gt; action) {
<span class="fc" id="L75">            return new PlanNodeBuilderRuleConsumer(predicate, action, method);</span>
        }


        public PlanNodeBuilderRuleConsumer assertThat(
            Predicate&lt;PlanNodeBuilder&gt; assertion,
            Function&lt;PlanNodeBuilder, String&gt; messageSuplier
        ) {
<span class="nc" id="L83">            return new PlanNodeBuilderRuleConsumer(predicate, node -&gt; {</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">                if (!assertion.test(node)) {</span>
<span class="nc" id="L85">                    throw new KukumoException(messageSuplier.apply(node));</span>
                }
<span class="nc" id="L87">            }, method);</span>
        }


        @Override
        public void apply(PlanNodeBuilder plan) {
<span class="fc" id="L93">            List&lt;PlanNodeBuilder&gt; nodes = plan</span>
<span class="fc" id="L94">                .descendants()</span>
<span class="fc" id="L95">                .filter(predicate)</span>
<span class="fc" id="L96">                .collect(Collectors.toList());</span>
<span class="fc" id="L97">            method.apply(nodes, consumer);</span>
<span class="fc" id="L98">        }</span>


        public PlanNodeBuilderRuleBiConsumer given(
            Function&lt;PlanNodeBuilder, Optional&lt;PlanNodeBuilder&gt;&gt; rightNodeGetter
        ) {
<span class="fc" id="L104">            return new PlanNodeBuilderRuleBiConsumer(predicate, consumer, method, rightNodeGetter);</span>
        }
    }


    public static class PlanNodeBuilderRuleBiConsumer extends PlanNodeBuilderRuleConsumer {

        protected final Function&lt;PlanNodeBuilder, Optional&lt;PlanNodeBuilder&gt;&gt; rightNodeGetter;


        private PlanNodeBuilderRuleBiConsumer(
                        Predicate&lt;PlanNodeBuilder&gt; predicate,
                        Consumer&lt;PlanNodeBuilder&gt; consumer,
                        RuleMethod method,
                        Function&lt;PlanNodeBuilder, Optional&lt;PlanNodeBuilder&gt;&gt; rightNodeGetter
        ) {
<span class="fc" id="L120">            super(predicate, consumer, method);</span>
<span class="fc" id="L121">            this.rightNodeGetter = rightNodeGetter;</span>
<span class="fc" id="L122">        }</span>


        public PlanNodeBuilderRuleBiConsumer perform(
            BiConsumer&lt;PlanNodeBuilder, PlanNodeBuilder&gt; action
        ) {
<span class="fc" id="L128">            return new PlanNodeBuilderRuleBiConsumer(</span>
<span class="fc" id="L129">                predicate, biconsume(rightNodeGetter, action), method, rightNodeGetter</span>
            );
        }

    }


    private static Consumer&lt;PlanNodeBuilder&gt; biconsume(
        Function&lt;PlanNodeBuilder, Optional&lt;PlanNodeBuilder&gt;&gt; rightNodeGetter,
        BiConsumer&lt;PlanNodeBuilder, PlanNodeBuilder&gt; action
    ) {
<span class="fc" id="L140">        return leftNode -&gt; rightNodeGetter.apply(leftNode)</span>
<span class="fc" id="L141">            .ifPresent(rightNode -&gt; action.accept(leftNode, rightNode));</span>
    }

    public static PlanNodeBuilderRuleConsumer forEachNode() {
<span class="fc" id="L145">        return forEachNode(it-&gt;true);</span>
    }


    public static PlanNodeBuilderRuleConsumer forEachNode(Predicate&lt;PlanNodeBuilder&gt; predicate) {
<span class="fc" id="L150">        return new PlanNodeBuilderRuleConsumer(predicate, x -&gt; {</span>
<span class="nc" id="L151">        }, RuleMethod.ALL);</span>
    }


    public static PlanNodeBuilderRuleConsumer forFirstNode(Predicate&lt;PlanNodeBuilder&gt; predicate) {
<span class="nc" id="L156">        return new PlanNodeBuilderRuleConsumer(predicate, x -&gt; {</span>
<span class="nc" id="L157">        }, RuleMethod.FIRST);</span>
    }


    public static Function&lt;PlanNodeBuilder, Optional&lt;PlanNodeBuilder&gt;&gt; anyOtherNode(
        Predicate&lt;PlanNodeBuilder&gt; predicate,
        BiPredicate&lt;PlanNodeBuilder, PlanNodeBuilder&gt; biPredicate
    ) {
<span class="fc" id="L165">        return leftNode -&gt; leftNode.root().descendants()</span>
<span class="fc" id="L166">            .filter(predicate)</span>
<span class="fc" id="L167">            .filter(rightNode -&gt; biPredicate.test(leftNode, rightNode))</span>
<span class="fc" id="L168">            .findAny();</span>
    }


    public static &lt;T&gt; BiPredicate&lt;PlanNodeBuilder, PlanNodeBuilder&gt; sharing(
        Function&lt;PlanNodeBuilder, T&gt; method
    ) {
<span class="fc" id="L175">        return (leftNode, rightNode) -&gt; Objects</span>
<span class="fc" id="L176">            .equals(method.apply(leftNode), method.apply(rightNode));</span>
    }


    public static &lt;T&gt; BiPredicate&lt;PlanNodeBuilder, PlanNodeBuilder&gt; sharing(
        Function&lt;PlanNodeBuilder, Optional&lt;PlanNodeBuilder&gt;&gt; leftNodeGetter,
        Function&lt;PlanNodeBuilder, Optional&lt;PlanNodeBuilder&gt;&gt; rightNodeGetter,
        Function&lt;PlanNodeBuilder, T&gt; method
    ) {
<span class="fc" id="L185">        return (leftNode, rightNode) -&gt; {</span>
<span class="fc" id="L186">            Optional&lt;PlanNodeBuilder&gt; actualLeftNode = leftNodeGetter.apply(leftNode);</span>
<span class="fc" id="L187">            Optional&lt;PlanNodeBuilder&gt; actualRightNode = rightNodeGetter.apply(rightNode);</span>
<span class="pc bpc" id="L188" title="2 of 4 branches missed.">            return actualLeftNode.isPresent() &amp;&amp; actualRightNode.isPresent() &amp;&amp;</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">                            Objects.equals(method.apply(actualLeftNode.get()), method.apply(actualRightNode.get()));</span>
        };
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withAny(
        Function&lt;PlanNodeBuilder, Stream&lt;PlanNodeBuilder&gt;&gt; stream,
        Predicate&lt;PlanNodeBuilder&gt; predicate
    ) {
<span class="nc" id="L198">        return node -&gt; stream.apply(node).anyMatch(predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withAll(
        Function&lt;PlanNodeBuilder, Stream&lt;PlanNodeBuilder&gt;&gt; stream,
        Predicate&lt;PlanNodeBuilder&gt; predicate
    ) {
<span class="nc" id="L206">        return node -&gt; stream.apply(node).allMatch(predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withSome(
        LongPredicate number,
        Function&lt;PlanNodeBuilder, Stream&lt;PlanNodeBuilder&gt;&gt; stream,
        Predicate&lt;PlanNodeBuilder&gt; predicate
    ) {
<span class="nc" id="L215">        return node -&gt; number.test(stream.apply(node).filter(predicate).count());</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withProperty(String key, String value) {
<span class="fc" id="L220">        return node -&gt; value.equals(node.properties().get(key));</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withTag(String tag) {
<span class="fc" id="L225">        return node -&gt; node.tags().contains(tag);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withType(NodeType type) {
<span class="fc bfc" id="L230" title="All 2 branches covered.">        return node -&gt; node.nodeType() == type;</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withTypeAnyOf(NodeType... types) {
<span class="nc" id="L235">        return node -&gt; node.nodeType().isAnyOf(types);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withTypeNoneOf(NodeType... types) {
<span class="nc" id="L240">        return node -&gt; node.nodeType().isNoneOf(types);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withParent(Predicate&lt;PlanNodeBuilder&gt; predicate) {
<span class="nc" id="L245">        return node -&gt; node.parent().filter(predicate).isPresent();</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withoutChildren() {
<span class="fc bfc" id="L250" title="All 2 branches covered.">        return node -&gt; node.numChildren() == 0;</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withAnyChild(Predicate&lt;PlanNodeBuilder&gt; predicate) {
<span class="nc" id="L255">        return withAny(PlanNodeBuilder::children, predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withEveryChild(Predicate&lt;PlanNodeBuilder&gt; predicate) {
<span class="nc" id="L260">        return withAll(PlanNodeBuilder::children, predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withSomeChildren(
        LongPredicate number,
        Predicate&lt;PlanNodeBuilder&gt; predicate
    ) {
<span class="nc" id="L268">        return withSome(number, PlanNodeBuilder::children, predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withAnyDescendant(
        Predicate&lt;PlanNodeBuilder&gt; predicate
    ) {
<span class="nc" id="L275">        return withAny(PlanNodeBuilder::descendants, predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withEveryDescendant(
        Predicate&lt;PlanNodeBuilder&gt; predicate
    ) {
<span class="nc" id="L282">        return withAll(PlanNodeBuilder::descendants, predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withSomeDescendants(
        LongPredicate number,
        Predicate&lt;PlanNodeBuilder&gt; predicate
    ) {
<span class="nc" id="L290">        return withSome(number, PlanNodeBuilder::children, predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withAnyAncestor(Predicate&lt;PlanNodeBuilder&gt; predicate) {
<span class="nc" id="L295">        return withAny(PlanNodeBuilder::ancestors, predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withEveryAncestor(
        Predicate&lt;PlanNodeBuilder&gt; predicate
    ) {
<span class="nc" id="L302">        return withAll(PlanNodeBuilder::ancestors, predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withSomeAncestors(
        LongPredicate number,
        Predicate&lt;PlanNodeBuilder&gt; predicate
    ) {
<span class="nc" id="L310">        return withSome(number, PlanNodeBuilder::ancestors, predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withAnySibling(Predicate&lt;PlanNodeBuilder&gt; predicate) {
<span class="nc" id="L315">        return withAny(PlanNodeBuilder::siblings, predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withEverySibling(
        Predicate&lt;PlanNodeBuilder&gt; predicate
    ) {
<span class="nc" id="L322">        return withAll(PlanNodeBuilder::siblings, predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; withSomeSiblings(
        LongPredicate number,
        Predicate&lt;PlanNodeBuilder&gt; predicate
    ) {
<span class="nc" id="L330">        return withSome(number, PlanNodeBuilder::siblings, predicate);</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; anyNode(Predicate&lt;PlanNodeBuilder&gt; predicate) {
<span class="fc" id="L335">        return predicate;</span>
    }


    public static Predicate&lt;PlanNodeBuilder&gt; childOf(Predicate&lt;PlanNodeBuilder&gt; predicate) {
<span class="fc" id="L340">        return node -&gt; node.parent().map(predicate::test).orElse(false);</span>
    }


    public static Consumer&lt;PlanNodeBuilder&gt; removeNode() {
<span class="fc" id="L345">        return node -&gt; node.parent().ifPresent(parent -&gt; parent.removeChild(node));</span>
    }


    public static BiConsumer&lt;PlanNodeBuilder, PlanNodeBuilder&gt; copyProperties() {
<span class="fc" id="L350">        return (leftNode, rightNode) -&gt; leftNode.addProperties(rightNode.properties());</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>