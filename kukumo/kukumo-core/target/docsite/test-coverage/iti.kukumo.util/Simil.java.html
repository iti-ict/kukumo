<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Simil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Kukumo::CORE</a> &gt; <a href="index.source.html" class="el_package">iti.kukumo.util</a> &gt; <span class="el_source">Simil.java</span></div><h1>Simil.java</h1><pre class="source lang-java linenums">/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package iti.kukumo.util;


import java.util.*;
import java.util.regex.Pattern;


/* CATMA Computer Aided Text Markup and Analysis*
 *  Copyright (C) 2008-2010  University Of Hamburg*
 *  This program is free software: you can redistribute it and/or modify *
 *  it under the terms of the GNU General Public License as published by *
 *  the Free Software Foundation, either version 3 of the License, or *
 *  (at your option) any later version.*
 *  This program is distributed in the hope that it will be useful, *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *
 *  GNU General Public License for more details.*
 *  You should have received a copy of the GNU General Public License *
 *  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *  */

/** Implementation of the Ratcliff/Obershelp Pattern Matching Algorithm as *
 *  described in the July 1988 issue of &lt;a href=http://www.ddj.com/184407970?pgno=5&gt;Dr. Dobbs Journal&lt;/a&gt;*
 *   @author Marco Petris
 *
 *   @author Luis IÃ±esta - luiinge@gmail.com (Additional tweaks and fixes)
 */
public class Simil {

    private final String upBaseInput;


    /**
     * Constructor.
     *
     * @param baseInput the basic input to compare against
     */
<span class="fc" id="L44">    public Simil(String baseInput) {</span>
<span class="fc" id="L45">        upBaseInput = baseInput.toUpperCase();</span>
<span class="fc" id="L46">    }</span>


    /**
     * This method takes two strings, one from each stack, and looks for the
     * largest substring which both have in common. The fragments of the two
     * strings which do not belong to the common substring are pushed on the
     * stacks. The size of the common susbstring is returned.
     *
     * @param baseInputStack the stack with the remaining portions of the base
     *                       input string which await examination
     * @param inputStack     the stack with the remaining portions of the input
     *                       string which await examination
     * @return the size of the largets common substring of the two strings which
     *         were on the tops of the incoming stacks.
     */
    private int compare(Deque&lt;String&gt; baseInputStack, Deque&lt;String&gt; inputStack) {

<span class="fc" id="L64">        String comp1 = baseInputStack.pop();</span>
<span class="fc" id="L65">        String comp2 = inputStack.pop();</span>

        // we start with the largest possible size
<span class="fc" id="L68">        int windowSize = Math.min(comp1.length(), comp2.length());</span>

        // loop over the decrementing size until we find
        // a common substring
<span class="fc bfc" id="L72" title="All 2 branches covered.">        while (windowSize &gt; 0) {</span>

            // we start to compare subtrings of the current windowsize
            // from the beginning of the base input fragment
            // and move forward with this window by one-character-steps until
            // we find a match
<span class="fc" id="L78">            int pos = 0;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">            while (pos + windowSize - 1 &lt; comp1.length()) {</span>

                // is this a common substring?
<span class="fc bfc" id="L82" title="All 2 branches covered.">                if (comp2.contains(comp1.substring(pos, pos + windowSize))) {</span>

                    // yes, so we take the parts that do not belong to our matching
                    // string and push them onto the stack for later examination
<span class="fc" id="L86">                    String[] comp2Rest = comp2.split(Pattern.quote(comp1.substring(pos, pos + windowSize)), 2);</span>
<span class="fc" id="L87">                    String[] comp1Rest = comp1.split(Pattern.quote(comp1.substring(pos, pos + windowSize)), 2);</span>

                    // both rest-arrays should have at least one entry to compare to next time
<span class="fc" id="L90">                    int resultLen = Math.min(comp1Rest.length, comp2Rest.length);</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">                    if (resultLen &gt; 1) {</span>
                        // we do not push empty fragments onto the stack
                        // but everything else
<span class="fc bfc" id="L94" title="All 2 branches covered.">                        for (int idx = 0; idx &lt; resultLen; idx++) {</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">                            if (!&quot;&quot;.equals(comp1Rest[idx])) {</span>
<span class="fc" id="L96">                                baseInputStack.push(comp1Rest[idx]);</span>
                            }
<span class="fc bfc" id="L98" title="All 2 branches covered.">                            if (!&quot;&quot;.equals(comp2Rest[idx])) {</span>
<span class="fc" id="L99">                                inputStack.push(comp2Rest[idx]);</span>
                            }
                        }
                    }
                    // this is the size of the first largest substring we could find
<span class="fc" id="L104">                    return windowSize;</span>
                }
                // nothing so far, so we move the window one character forward
<span class="fc" id="L107">                pos++;</span>
            }
            // nothing so far, so we make the window (substring size) smaller
<span class="fc" id="L110">            windowSize--;</span>
<span class="fc" id="L111">        }</span>

<span class="fc" id="L113">        return 0;</span>
    }


    /**
     * Computes the similarity of the base input of this instance to the given
     * input and returns the computed value in percent.
     *
     * @param input the input to compare with the basic input of this instance
     * @return the percentage value of similarity
     */
    public double getSimilarityInPercentFor(String input) {
<span class="fc" id="L125">        String upInput = input.toUpperCase();</span>
<span class="fc" id="L126">        Deque&lt;String&gt; inputStack = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L127">        Deque&lt;String&gt; baseInputStack = new ArrayDeque&lt;&gt;();</span>

<span class="fc" id="L129">        baseInputStack.push(upBaseInput);</span>
<span class="fc" id="L130">        inputStack.push(upInput);</span>

        // total length of the matching substrings
<span class="fc" id="L133">        int compCount = 0;</span>

        // we loop over the portions of the strings and try to find
        // the lengths of largest substrings
        // the stacks gets filled when common substrings are found
<span class="fc bfc" id="L138" title="All 4 branches covered.">        while (!inputStack.isEmpty() &amp;&amp; !baseInputStack.isEmpty()) {</span>

<span class="fc" id="L140">            compCount += compare(baseInputStack, inputStack);</span>

        }

        // compute the percent value for the total length of the matching substrings
        // regarding the combined total length of the two strings we compared
<span class="fc" id="L146">        double percentVal = (compCount * 2);</span>
<span class="fc" id="L147">        percentVal /= (upBaseInput.length() + upInput.length());</span>

<span class="fc" id="L149">        return (int) (Math.round(percentVal * 100.0));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>